(('RULE', ('NAME', ('IDENT', 'visible_ascii')), ('FUNC',), ('RANGE', ('TERM', '!'), ('TERM', '~'))), ('RULE', ('NAME', ('IDENT', 'whitespace')), ('FUNC',), ('ALT', ('TERM', ' '), ('TERM', '\n'), ('TERM', '\t'), ('TERM', '\r'), ('TERM', '\x0c'), ('TERM', '\x08'))), ('RULE', ('NAME', ('IDENT', 'character')), ('FUNC',), ('ALT', ('IDENT', 'visible_ascii'), ('IDENT', 'whitespace'))), ('RULE', ('NAME', ('IDENT', 'letter')), ('FUNC',), ('ALT', ('RANGE', ('TERM', 'A'), ('TERM', 'Z')), ('RANGE', ('TERM', 'a'), ('TERM', 'z')))), ('RULE', ('NAME', ('IDENT', 'digit')), ('FUNC',), ('RANGE', ('TERM', '0'), ('TERM', '9'))), ('RULE', ('NAME', ('IDENT', 'S')), ('FUNC', ('BLOCK', ' discard ')), ('ANY', ('IDENT', 'whitespace'))), ('RULE', ('NAME', ('IDENT', 'quantifier')), ('FUNC',), ('ALT', ('TERM', '+'), ('TERM', '*'), ('TERM', '?'))), ('RULE', ('NAME', ('IDENT', 'identifier')), ('FUNC', ('BLOCK', " lambda xs: (('IDENT', *concat(xs)),) ")), ('ALT', ('IDENT', 'letter'), ('SEQ', ('IDENT', 'letter'), ('ANY', ('ALT', ('IDENT', 'letter'), ('IDENT', 'digit'), ('TERM', '_'), ('TERM', ' '))), ('ALT', ('IDENT', 'letter'), ('IDENT', 'digit'), ('TERM', '_'))))), ('RULE', ('NAME', ('IDENT', 'single_terminal')), ('FUNC', ('BLOCK', " lambda xs: (('TERM', *convert_escaped(concat(xs[1:-1])[0])),) ")), ('ALT', ('SEQ', ('TERM', "'"), ('MANY', ('DIFF', ('IDENT', 'character'), ('TERM', "'"))), ('TERM', "'")), ('SEQ', ('TERM', '"'), ('MANY', ('ALT', ('DIFF', ('IDENT', 'character'), ('TERM', '"')), ('TERM', '\\', '"'))), ('TERM', '"')))), ('RULE', ('NAME', ('IDENT', 'range_terminal')), ('FUNC', ('BLOCK', " lambda xs: (('RANGE', xs[0], xs[-1]),) ")), ('SEQ', ('IDENT', 'single_terminal'), ('IDENT', 'S'), ('TERM', '.', '.', '.'), ('IDENT', 'S'), ('IDENT', 'single_terminal'))), ('RULE', ('NAME', ('IDENT', 'cut')), ('FUNC', ('BLOCK', " lambda _: (('CUT',),) ")), ('TERM', '!')), ('RULE', ('NAME', ('IDENT', 'terminal')), ('FUNC',), ('ALT', ('IDENT', 'single_terminal'), ('IDENT', 'range_terminal'), ('IDENT', 'cut'))), ('RULE', ('NAME', ('IDENT', 'paren_term')), ('FUNC', ('BLOCK', ' lambda xs: xs[1:-1] ')), ('SEQ', ('TERM', '('), ('IDENT', 'S'), ('IDENT', 'rhs'), ('IDENT', 'S'), ('TERM', ')'))), ('RULE', ('NAME', ('IDENT', 'term')), ('FUNC',), ('ALT', ('IDENT', 'paren_term'), ('IDENT', 'terminal'), ('IDENT', 'identifier'))), ('RULE', ('NAME', ('IDENT', 'quantified_expression')), ('FUNC', ('BLOCK', " lambda xs: ({'*': 'ANY', '+': 'MANY', '?': 'OPT'}[xs[-1]], xs[0]) ")), ('SEQ', ('IDENT', 'term'), ('IDENT', 'S'), ('IDENT', 'quantifier'))), ('RULE', ('NAME', ('IDENT', 'difference_expression')), ('FUNC', ('BLOCK', " lambda xs: ('DIFF', xs[0], xs[2]) ")), ('SEQ', ('IDENT', 'term'), ('IDENT', 'S'), ('TERM', '-'), ('IDENT', 'S'), ('IDENT', 'term'))), ('RULE', ('NAME', ('IDENT', 'factor_expression')), ('FUNC', ('BLOCK', ' wrap ')), ('ALT', ('IDENT', 'quantified_expression'), ('IDENT', 'difference_expression'))), ('RULE', ('NAME', ('IDENT', 'factor')), ('FUNC',), ('ALT', ('IDENT', 'factor_expression'), ('IDENT', 'term'))), ('RULE', ('NAME', ('IDENT', 'concatenation')), ('FUNC', ('BLOCK', " lambda xs: (('SEQ', *[x for i, x in enumerate(xs) if i % 2 == 0]),) if len(xs) > 1 else xs ")), ('SEQ', ('IDENT', 'factor'), ('ANY', ('SEQ', ('IDENT', 'S'), ('TERM', ','), ('IDENT', 'S'), ('IDENT', 'factor'))))), ('RULE', ('NAME', ('IDENT', 'alternation')), ('FUNC', ('BLOCK', " lambda xs: (('ALT', *[x for i, x in enumerate(xs) if i % 2 == 0]),) if len(xs) > 1 else xs ")), ('SEQ', ('IDENT', 'concatenation'), ('ANY', ('SEQ', ('IDENT', 'S'), ('TERM', '|'), ('IDENT', 'S'), ('IDENT', 'concatenation'))))), ('RULE', ('NAME', ('IDENT', 'block')), ('FUNC',), ('SEQ', ('TERM', '{'), ('ANY', ('ALT', ('DIFF', ('IDENT', 'character'), ('ALT', ('TERM', '{'), ('TERM', '}'))), ('IDENT', 'block'))), ('TERM', '}'))), ('RULE', ('NAME', ('IDENT', 'outer_block')), ('FUNC', ('BLOCK', " lambda xs: (('BLOCK', concat(xs[1:-1])[0]),)")), ('IDENT', 'block')), ('RULE', ('NAME', ('IDENT', 'rhs')), ('FUNC',), ('IDENT', 'alternation')), ('RULE', ('NAME', ('IDENT', 'lhs')), ('FUNC', ('BLOCK', " lambda xs: (('NAME', xs[0]), ('FUNC', *(xs[1:]))) ")), ('SEQ', ('IDENT', 'identifier'), ('OPT', ('SEQ', ('IDENT', 'S'), ('IDENT', 'outer_block'))))), ('RULE', ('NAME', ('IDENT', 'rule')), ('FUNC', ('BLOCK', " lambda xs: (('RULE', xs[0], xs[1], xs[3]),) ")), ('SEQ', ('IDENT', 'lhs'), ('IDENT', 'S'), ('TERM', '='), ('IDENT', 'S'), ('IDENT', 'rhs'), ('IDENT', 'S'), ('TERM', ';'), ('CUT',), ('IDENT', 'S'))), ('RULE', ('NAME', ('IDENT', 'grammar')), ('FUNC',), ('ANY', ('SEQ', ('IDENT', 'S'), ('IDENT', 'rule'), ('IDENT', 'S')))))
